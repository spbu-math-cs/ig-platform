# Приложение для проведения интерактивных викторин в формате крестики-нолики, общий дизайн

Этот документ содержит изначальный верхнеуровневый дизайн приложения CLVR, позволяющего проводить интеллектуальные игры в формате крестики-нолики.

Игра подразумевает наличие двух команд -- "команды крестиков" и "команды ноликов".
Команды по очереди выбирают темы, и команде, правильно ответившей на вопрос, дается право поставить свой символ на поле.
Цель команды -- выложить на поле комбинацию из 3х подряд своих символов, как в классической игре.
Более подробные правила см. в [правилах](https://gist.github.com/sh-ad/07676a0a3d56b577f4abfa0d477b9d9b). 

## Применения

Такой формат викторин уже используется, однако всю механику игры приходится делать вручную.
В результате этого сильно усложняется задача ведущего, повышается вероятность ошибок.
Приложение для проведения такой викторины поможет сильно упростить процесс игры и избежать возможных ошибок и разногласий.

## Контекст

Приложение будет состоять из двух частей -- клиента и сервера.
Сервер будет выполнять две основные задачи:
1. Хранение и осуществление доступа к викторинам (т.е. заранее заготовленным спискам вопросов/ответов)
2. Проведение игр -- пользователь выбирает викторину и начинает игру, после этого сервер должен обрабатывать запросы других участников на подключение, поддерживать состояние игры и раздавать его участникам.

## Предложенный дизайн

### API

Получение списка викторин, а также подключение к конкретной сессии будет сделано через REST.
Во время сессии передача состояния игры и всех изминений между клиентом и сервером будет происходить через WebSockets.
[Подробное описание API](API-doc.md)

### Клиентская часть

Приложение должно предоставлять следующие интерфейсы:
  1. Интерфейс редактора, в котором можно создать викторину, указав вопросы, подсказки и правильные отевты
  2. Интерфейс жюри, в котором ведущий будет видеть вопрос, подсказки и правильный ответ, а также сможет отмечать правильно ответившую команду.
  Также должна быть возможность размещения символов за участников
  (это позволит проводить викторины, где участники будут взаимодействовать только с ведущим, но не с приложением)
  3. Интерфейс зрителя, в котором будут видны поле, темы вопросов и очередность хода (а после выбора темы на него также можно выводить текст вопроса и подсказок).
  4. Интерфейс участника, в котором играющие могут размещать свой символ в случае правильного ответа
 
Интерфейс жюри должен присутствовать обязательно, интерфейс автора на начальных этапах можно заменить подкачкой вопросов для викторин из файла, где они задаются в отдельно описанном формате. 
Интерфейсы зрителя и участника также не обязательны на первых этапах разработки приложения.

### Серверная часть

1. Сервер должен иметь доступ к базе данных с викторинами.
Изначально достаточно чтобы это был какой-то json-файл, который будет подгружаться в память, в дальнейшем для этого необходима база данных.

2. Сервер должен обрабатывать REST-запросы на создание новой игровой сессии и подключение к ней. В дальнейшем необходимо также через REST уметь обрабатывать запросы на добавление викторины в базу или ее редактирование.

3. Для каждой игровой сессии сервер должен поддерживать текущее состояние игры, а также WebSocket-соединение со всеми ее участниками, чтобы принимать и рассылать обновления этого состояния.


## Проблемы и альтернативы

### Забракованные идеи

1. Мы отказались от идеи Stateless-сервера, т.к. в таком случае клиенту ведущего придется поддерживать p2p-соединения со всеми игроками, что сложнее реализовать и что начинает очень плохо работать, если у ведущего проблемы с соединением.
2. Мы отказались от идеи делать весь API через REST, т.к. во время игры нам необходимо иметь дуплексное соединение между клиентами и сервером (нам нужно собирать изменения о клиентах, но также оповещать их об изменениях сделанных другими).
3. Мы отказались от идеи написать все на WebSockets, т.к. это усложнит общение между сервером и клиентом до захода клиента в сессию.

### Актуальные вопросы на будущее

* Возможно, нужен интерфейс, который будет совпадать со зрительским, но в котором участники обеих команд могут делать свой ход --
  тогда для проведения викторины понадобится один такой интерфейс и один интерфейс жюри
* Надо понять, интересны ли поля кастомных размеров
* Если упростить вопросы и увеличить их количество, то возможно интересней будет сделать то же самое, но с морским боем

## Принятые решения

- Клиентская часть будет реализована с помощью React.
- Серверная часть будет реализована на Kotlin

## Ссылки

- [Подробные правила игры](https://gist.github.com/sh-ad/07676a0a3d56b577f4abfa0d477b9d9b)
- [Отчасти похожая популярная платформа](kahoot.it)
